#!/usr/bin/env python3
'''
pukahaPai
=========

DearPyGui controller+viewer for ODE simulations with shared memory
interoperability.

Usage:
------
Requires an existing Julia ODES solver, which should be auto-code generated by
the python script.  For example,
```bash
./generate_julia_odesolver.py pendulum
```
This presumes an ODES model specification `pendulum.toml` exists in 
the `./models` directory.  If successful the generated Julia code will be 
in `./models/pendulum.jl`.


| Copyright: (c) 2025 Bijou M. Smith
| License: GNU General Public License v3.0
  <https://www.gnu.org/licenses/gpl-3.0.html>
'''
import os
import signal
import threading
import os
import toml
import sys
import ctypes
from multiprocessing import shared_memory
import subprocess
import threading
import time
import colorsys
import dearpygui.dearpygui as dpg 

# -------- Configuration --------
INIT_PATH = "./init"
MODELS_DIR = "./models"
SHM_NAME = "pukaha_shared"
BUFF = 25
USE_LEGEND = False


def load_model_spec(model_path):
    """Enhanced to include tspan parameters"""
    data = toml.load(model_path)
    # Parse regular parameters
    raw_params = data.get("parameters", {})
    parsed = {}
    for name, val in raw_params.items():
        if isinstance(val, float):
            parsed[name] = ("c_double", val)
        elif isinstance(val, int):
            parsed[name] = ("c_int", val)
        else:
            raise ValueError(f"Unsupported param type for '{name}'")
    # Add tspan parameters to shared memory
    tspan = data.get("tspan", {})
    # get time window toml from [tspan] section t0, t1
    t0 = tspan.get("t0", 0.0)
    t1 = tspan.get("t1", 10.0)
    parsed["t0"] = ("c_double", t0)
    parsed["t1"] = ("c_double", t1)  # This becomes controllable
    return parsed



# -------- Load Init File and TOML Model --------
def get_model_path():
    if not os.path.exists(INIT_PATH):
        print("Error: Missing './init'. Please create a file with one line: model name.")
        sys.exit(1)
    with open(INIT_PATH, "r") as f:
        model_name = f.read().strip()
    model_path = os.path.join(MODELS_DIR, f"{model_name}.toml")
    if not os.path.exists(model_path):
        print(f"Error: Model file '{model_path}' not found.")
        sys.exit(1)
    julia_prog = f"{MODELS_DIR}/{model_name}_gui.jl"
    if not os.path.exists(f"{julia_prog}"):
        print(f"Error: Julia module {julia_prog} does not exist. Use the code generator to make it.")
        sys.exit(1)
    return model_name, model_path


def extract_variable_names(model_path):
    """Extract ODE variable names from [variables] and initial values from [initial_conditions]."""
    data = toml.load(model_path)
    var_section = data.get("variables", {})
    ic_section = data.get("initial_conditions", {})
    y_names = var_section.get("names", [])
    y0 = [ic_section.get(name, 0.0) for name in y_names]
    print(f"Extracted variable names: {y_names} with initial values: {y0}")
    return y_names, y0


#------------ Plot Methods --------------
# Color palette generation
def generate_colors(n):
    """Generate n distinct colors using HSV color space"""
    colors = []
    for i in range(n):
        hue = i / n
        # Use high saturation and value for vibrant colors
        rgb = colorsys.hsv_to_rgb(hue, 0.8, 0.9)
        # Convert to 0-255 range (no alpha needed for theme colors)
        colors.append((int(rgb[0] * 255), int(rgb[1] * 255), int(rgb[2] * 255)))
    return colors


def create_line_series_theme(color, theme_tag):
    """Create a theme for line series with specified color"""
    with dpg.theme(tag=theme_tag):
        with dpg.theme_component(dpg.mvLineSeries):
            dpg.add_theme_color(dpg.mvPlotCol_Line, color, category=dpg.mvThemeCat_Plots)
            # Optionally add other styling
            dpg.add_theme_style(dpg.mvPlotStyleVar_LineWeight, 2, category=dpg.mvThemeCat_Plots)


def add_single_variable_plot(parent, y_name, tspan, color):
    """Create a properly configured plot with specified color"""
    parent_width = dpg.get_item_width(parent)
    # Create unique theme for this series
    theme_tag = f"theme_{y_name}"
    create_line_series_theme(color, theme_tag)
    with dpg.plot(label=f"{y_name} vs Time", height=180, width=parent_width - 25, parent=parent):
        # Optionally create legend
        if USE_LEGEND:
            dpg.add_plot_legend()
        x_axis = dpg.add_plot_axis(dpg.mvXAxis, label="Time", tag=f"x_axis_{y_name}")
        y_axis = dpg.add_plot_axis(dpg.mvYAxis, label=y_name, tag=f"y_axis_{y_name}")
        series = dpg.add_line_series([], [], label=y_name, parent=y_axis, tag=f"series_{y_name}")
        # Bind theme ONLY to this specific series (not globally)
        dpg.bind_item_theme(series, theme_tag)
        dpg.set_axis_limits(x_axis, tspan[0], tspan[1])
        dpg.set_axis_limits(y_axis, -1, 1)  # Initial guess, will auto-scale
        return series, f"x_axis_{y_name}", f"y_axis_{y_name}"



def update_plots(model_name, y_names, plot_data, plot_ctrl):
    """Enhanced plot updating with throttling and better axis scaling.
    No explicit `tspan` here, we use whatever is in the CSV file 
    from the julia solver."""
    # Check throttle
    current_time = time.time()
    if current_time - plot_ctrl.last_plot_update < plot_ctrl.throttle_delay:
        return
    csv_path = f"models/{model_name}.csv"
    if not os.path.exists(csv_path):
        return
        
    try:
        with open(csv_path, 'r') as f:
            lines = [line.strip() for line in f.readlines()[1:] if line.strip()]
            if not lines:
                return
            # Also skip plot update if no new lines
            if len(lines) == plot_ctrl.last_csvlines_len:
                return  # nothing new â†’ skip redraw
            plot_ctrl.last_csvlines_len = len(lines)
            # Use last 1000 points but respect throttling
            data = [line.split(',') for line in lines]
            t = [float(row[0]) for row in data]
            if not t:
                return
                
            for i, y_name in enumerate(y_names, start=1):
                series_tag, x_axis_tag, y_axis_tag = plot_data[y_name]
                y_values = [float(row[i]) for row in data]
                
                # Update data series
                dpg.set_value(series_tag, [t, y_values])
                
                # Enhanced X axis scaling
                if len(t) > 1:
                    # margin = 0.01 * (t[-1] - t[0]) if len(t) > 1 else 1.0
                    # dpg.set_axis_limits(x_axis_tag, t[0], t[-1] + margin)
                    margin = 0.01 * (t[-1] - t[0]) 
                    dpg.set_axis_limits(x_axis_tag, 0.0, t[-1] + margin)
    
                # Auto-scale Y axis with better padding
                if y_values:
                    y_min = min(y_values)
                    y_max = max(y_values)
                    if y_max != y_min:
                        padding = 0.1 * (y_max - y_min)
                    else:
                        padding = 0.1
                    dpg.set_axis_limits(y_axis_tag, y_min - padding, y_max + padding)
        
        plot_ctrl.last_plot_update = current_time
                    
    except Exception as e:
        print(f"Plot update error: {e}")


class PlotController:
    '''Optional, but useful for inspecting transients perhaps.'''
    def __init__(self, param_dict):
        self.last_csvlines_len = 0
        self.tspan = [param_dict['t0'][1], param_dict['t1'][1]]
        self.throttle_delay = 0.0  # No throttle by default
        self.last_plot_update = 0.0
        
    def set_throttle(self, delay_ms):
        """Set plot update throttle in milliseconds"""
        self.throttle_delay = delay_ms / 1000.0



# -------------------- Shared memory handling section -------------------
def create_ctypes_struct(param_dict):
    """Enhanced struct creation - order matters for Julia compatibility"""
    fields = [("state", ctypes.c_char)]
    # Add t0, t1 first (to match Julia struct order)
    if "t0" in param_dict:
        fields.append(("t0", ctypes.c_double))
    if "t1" in param_dict:
        fields.append(("t1", ctypes.c_double))
    
    # Add other parameters
    for name, (typ, _) in param_dict.items():
        if name not in ["t0", "t1"]:  # Skip these, already added
            fields.append((name, getattr(ctypes, typ)))
    return type("ParamStruct", (ctypes.Structure,), {"_fields_": fields})


class SharedSimState:
    def __init__(self, param_dict, model_name):
        self.ParamStruct = create_ctypes_struct(param_dict)
        self.struct_size = ctypes.sizeof(self.ParamStruct)
        self.param_dict = param_dict
        self.julia_script = f"./models/{model_name}_gui.jl"
        self._struct = None
        self.shm = None
        self.is_owner = False
        self.julia_process = None
        self._monitoring = False
        self._monitor_thread = None
        self._shutdown_event = threading.Event()
        
        try:
            # Create or attach to shared memory
            self.shm = shared_memory.SharedMemory(
                name=SHM_NAME,
                create=True,
                size=self.struct_size
            )
            self.is_owner = True
            self._struct = self.ParamStruct.from_buffer(self.shm.buf)
            self._struct.state = b'i'  # Initial state
            
            # Initialize parameters
            for name, (_, val) in param_dict.items():
                setattr(self._struct, name, val)
                
        except FileExistsError:
            # Attach to existing shared memory
            self.shm = shared_memory.SharedMemory(name=SHM_NAME)
            self._struct = self.ParamStruct.from_buffer(self.shm.buf)
            
        except Exception as e:
            self.cleanup_resources()
            raise RuntimeError(f"Shared memory init failed: {str(e)}")

    def struct(self):
        if self._struct is None:
            raise RuntimeError("Shared memory struct not initialized")
        return self._struct

    def set_state(self, s):
        """Thread-safe state update with validation"""
        if isinstance(s, str) and len(s) > 0:
            try:
                self._struct.state = s[0].encode()
                print(f"State set to: {s[0]}")
            except Exception as e:
                print(f"Failed to set state: {e}")
                raise
        else:
            self._struct.state = b'i'

    def get_state(self):
        """Thread-safe state getter"""
        try:
            return self._struct.state.decode()
        except:
            return 'i'  # Default to idle on error

    def set_param(self, name, value):
        """Validated parameter setter"""
        if name not in self.param_dict:
            raise ValueError(f"Invalid parameter: {name}")
        param_type, _ = self.param_dict[name]
        try:
            if param_type == "c_double":
                value = float(value)
            elif param_type == "c_int":
                value = int(value)
            setattr(self._struct, name, value)
        except (TypeError, ValueError) as e:
            raise ValueError(f"Invalid value for {name}: {str(e)}")

    def get_param(self, name):
        return getattr(self._struct, name)

    def start_julia_solver(self, model_name):
        """Start Julia solver with improved error handling"""
        # Stop existing process if running
        self.stop_julia_solver()
        
        if not os.path.exists(self.julia_script):
            print(f"Error: Julia solver '{self.julia_script}' not found.")
            return False
            
        try:
            # Clear shutdown event
            self._shutdown_event.clear()
            
            # Start Julia process with better environment
            env = os.environ.copy()
            env['JULIA_NUM_THREADS'] = '1'  # Avoid threading issues
            
            self.julia_process = subprocess.Popen(
                ["julia", "--startup-file=no", self.julia_script],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
                env=env,
                preexec_fn=os.setsid  # Create new process group
            )
            
            # Give Julia time to start up
            time.sleep(0.5)
            
            # Check if process started successfully
            if self.julia_process.poll() is not None:
                stderr_output = self.julia_process.stderr.read()
                print(f"Julia failed to start: {stderr_output}")
                return False
            
            # Start monitoring thread
            self._monitoring = True
            self._monitor_thread = threading.Thread(target=self._monitor_julia_process)
            self._monitor_thread.daemon = True
            self._monitor_thread.start()
            
            print("Julia solver started successfully")
            return True
            
        except Exception as e:
            print(f"Failed to start Julia solver: {e}")
            return False
    
    def _monitor_julia_process(self):
        """Enhanced monitoring with better error handling"""
        if not self.julia_process:
            return
            
        while self._monitoring and self.julia_process.poll() is None:
            try:
                # Check for shutdown signal
                if self._shutdown_event.is_set():
                    break
                    
                # Read stdout with timeout using select (Unix-like systems)
                import select
                ready, _, _ = select.select([self.julia_process.stdout], [], [], 0.1)
                
                if ready:
                    line = self.julia_process.stdout.readline()
                    if line:
                        print(f"Julia: {line.strip()}")
                        
            except Exception as e:
                print(f"Monitor error: {e}")
                break
            
            time.sleep(0.05)  # Reduced sleep for better responsiveness
        
        # Process ended - handle cleanup
        if self.julia_process:
            return_code = self.julia_process.poll()
            if return_code is not None and return_code != 0:
                # Process ended with error
                try:
                    stderr_output = self.julia_process.stderr.read()
                    if stderr_output:
                        print(f"Julia stderr: {stderr_output}")
                except:
                    pass
                
                # Set error state if not already shutting down
                if not self._shutdown_event.is_set():
                    self.set_state('e')
    
    def stop_julia_solver(self):
        """Improved graceful shutdown with timeout escalation"""
        if not self.julia_process:
            return
            
        print("Stopping Julia solver...")
        self._shutdown_event.set()
        
        try:
            # Step 1: Send quit signal via shared memory
            if self.julia_process.poll() is None:
                self.set_state('q')
                print("Sent quit signal to Julia")
                
                # Wait for graceful exit (up to 2 seconds)
                for i in range(20):  # 20 * 0.1s = 2s total
                    if self.julia_process.poll() is not None:
                        print("Julia exited gracefully")
                        break
                    time.sleep(0.1)
            
            # Step 2: Send SIGTERM if still running
            if self.julia_process.poll() is None:
                print("Sending SIGTERM to Julia process group")
                try:
                    os.killpg(os.getpgid(self.julia_process.pid), signal.SIGTERM)
                except (OSError, ProcessLookupError):
                    self.julia_process.terminate()
                
                # Wait for termination (up to 1 second)
                try:
                    self.julia_process.wait(timeout=1.0)
                    print("Julia terminated via SIGTERM")
                except subprocess.TimeoutExpired:
                    pass
            
            # Step 3: Force kill if absolutely necessary
            if self.julia_process.poll() is None:
                print("Force killing Julia process")
                try:
                    os.killpg(os.getpgid(self.julia_process.pid), signal.SIGKILL)
                except (OSError, ProcessLookupError):
                    self.julia_process.kill()
                
                try:
                    self.julia_process.wait(timeout=0.5)
                except subprocess.TimeoutExpired:
                    print("Warning: Julia process may still be running")
                    
        except Exception as e:
            print(f"Error during Julia shutdown: {e}")
        
        finally:
            # Stop monitoring thread
            self._monitoring = False
            if self._monitor_thread and self._monitor_thread.is_alive():
                self._monitor_thread.join(timeout=1.0)
            
            # Reset process reference
            self.julia_process = None
            
            # Set stopped state
            try:
                self.set_state('s')
            except:
                pass  # May fail if shared memory is being cleaned up
            
            print("Julia solver stop completed")
    
    def is_julia_running(self):
        """Check if Julia process is still running"""
        return (self.julia_process is not None and 
                self.julia_process.poll() is None and 
                not self._shutdown_event.is_set())

    def cleanup_resources(self):
        """Safe cleanup with proper null checks"""
        try:
            # Stop Julia first
            self.stop_julia_solver()
            
            if hasattr(self, '_struct') and self._struct is not None:
                del self._struct
                self._struct = None
                
            if hasattr(self, 'shm') and self.shm is not None:
                self.shm.close()
                if self.is_owner:
                    try:
                        self.shm.unlink()
                        print("Shared memory cleaned up")
                    except FileNotFoundError:
                        pass
                self.shm = None
                        
        except Exception as e:
            print(f"Cleanup error: {e}")

    def close(self):
        """Full cleanup"""
        print("Closing shared simulation state...")
        self.cleanup_resources()


# --------------------- Enhanced DearPyGui GUI ------------------------
def build_gui(model_name, param_dict, shared: SharedSimState):
    dpg.create_context()
    dpg.create_viewport(title=f"pukahaPai | {model_name}", width=1200, height=600)

    # Get variable names and generate colors
    y_names, _ = extract_variable_names(model_path)
    colors = generate_colors(len(y_names))
    plot_data = {}

    # Initialize plot controller
    plot_ctrl = PlotController(param_dict)
    plot_window = dpg.add_window(label="ODE Solution Plots", width=1000, height=600, pos=(210,0), tag="plot_window")
    
    for i, y_name in enumerate(y_names):
        plot_data[y_name] = add_single_variable_plot(plot_window, y_name, 
                                                     plot_ctrl.tspan, colors[i])

    # Control panel window
    with dpg.window(label=f"pukahaPai | {model_name}", width=200, height=600, tag="main_window"):
        dpg.add_text("Simulation Control Panel")
        dpg.add_separator()
        state_id = dpg.add_text(f"State: {shared.get_state()}", color=[255, 255, 0], tag="state_text")

        def refresh_state():
            current_state = shared.get_state()
            julia_running = shared.is_julia_running()
            # Update state display
            state_messages = {
                'i': "Idle",
                'r': "Running",
                'p': "Paused", 
                's': "Stopped",
                'e': "Error"
            }
            dpg.set_value(state_id, f"State: {state_messages.get(current_state, 'Unknown')}")
            # Update button states
            dpg.configure_item("start_button", 
                enabled=current_state in ['i', 'p', 's'],
                label="Start" if current_state in ['i', 's'] else "Resume")
            dpg.configure_item("pause_button",
                enabled=current_state == 'r')
            dpg.configure_item("stop_button",
                enabled=current_state in ['r', 'p'])

        # Plot control section
        dpg.add_separator()
        #dpg.add_text("Plot throttle (ms)")
        
        def throttle_callback(sender, value):
            plot_ctrl.set_throttle(value)
            print(f"Plot throttle set to {value}ms")
        
        dpg.add_slider_int(
            label="(ms)",
            default_value=0,
            min_value=0,
            max_value=1000,
            width=150,
            callback=throttle_callback,
            tag="throttle_slider"
        )
        dpg.add_text("0 = No throttle (fastest)", wrap=180)

        def make_param_callback(name):
            def callback(sender, app_data):
                shared.set_param(name, app_data)
                print(f"Parameter {name} updated to {app_data}")
            return callback

        # Parameter controls
        dpg.add_separator()
        dpg.add_text("Parameters")
        for name, (typ, _) in param_dict.items():
            if typ == "c_double":
                dpg.add_input_float(
                    label=name,
                    default_value=shared.get_param(name),
                    width=100,
                    callback=make_param_callback(name),
                    tag=f"param_{name}"
                )
            elif typ == "c_int":
                dpg.add_input_int(
                    label=name,
                    default_value=shared.get_param(name),
                    width=100,
                    callback=make_param_callback(name),
                    tag=f"param_{name}"
                )

        def start_simulation():
            """Start or resume simulation"""
            current_state = shared.get_state()
            
            if current_state == 'p':  # Resume from pause
                shared.set_state('r')
            else:  # Start new simulation
                if shared.start_julia_solver(model_name):
                    shared.set_state('r')
                    print("Julia solver started, simulation running")
                else:
                    print("Failed to start Julia solver")
            refresh_state()
        
        def pause_simulation():
            """Pause simulation"""
            shared.set_state('p')
            print("Simulation paused")
            refresh_state()

        def stop_simulation():
            """Improved orderly shutdown procedure"""
            print("Stop button pressed")
            
            try:
                current_state = shared.get_state()
                print(f"Current state before stop: {current_state}")
                
                # Always attempt to stop Julia solver
                shared.stop_julia_solver()
                
                # Verify final state
                final_state = shared.get_state()
                print(f"Final state after stop: {final_state}")
                
            except Exception as e:
                print(f"Stop error: {e}")
                # Force state update on error
                try:
                    shared.set_state('e')
                except:
                    pass
            finally:
                refresh_state()
                print("Stop procedure completed")

        # Control buttons
        dpg.add_separator()
        dpg.add_button(label="Start", tag="start_button", callback=start_simulation, width=80)
        dpg.add_button(label="Pause", tag="pause_button", callback=pause_simulation, width=80)
        dpg.add_button(label="Stop", tag="stop_button", callback=stop_simulation, width=80)

    # Time tracking for main GUI update loop
    last_update_time = 0
    update_interval = 0.1  # 100ms = 10 FPS for GUI state updates

    def render_callback():
        nonlocal last_update_time
        current_time = time.time()
        refresh_state()  # Always update GUI state
        # Plot updates are now throttled independently
        if current_time - last_update_time >= update_interval:
            if shared.get_state() == 'r' and shared._monitor_thread.is_alive():
                update_plots(model_name, y_names, plot_data, plot_ctrl)
            last_update_time = current_time

    # Main loop
    dpg.setup_dearpygui()
    dpg.show_viewport()
    
    while dpg.is_dearpygui_running():
        render_callback()
        dpg.render_dearpygui_frame()
    
    dpg.destroy_context()
    shared.close()


# --------- Program Entry (no main) ---------
model_name, model_path = get_model_path()

param_dict = load_model_spec(model_path)
# print(f"{param_dict = }")
# quit()
shared = SharedSimState(param_dict, model_name)
try:
    build_gui(model_name, param_dict, shared)
finally:
    shared.close()
# -*- coding: utf-8 -*-
# pendulum.jl  - for GUI slaving

using DifferentialEquations
import Base.Libc
using Mmap


# Auto-generated struct for shared memory interop
struct pendulum_Shared
    state::UInt8
    t0::Float64
    t1::Float64
    mass::Float64
    length::Float64
    damping::Float64
    g::Float64
end

function open_shared_pendulum()
    shmpath = "/dev/shm/pukaha_shared"
    sz = sizeof(pendulum_Shared)
    fd = open(shmpath, "r+")
    arr = Mmap.mmap(Array{UInt8}, fd, sz)
    return arr, Ptr{pendulum_Shared}(pointer(arr))
end

function read_shared_params()
    """Read current parameters from shared memory"""
    arr, ptr = open_shared_pendulum()
    return unsafe_load(ptr)
end

function write_shared_state(new_state::Char)
    """Write state back to shared memory"""
    arr, ptr = open_shared_pendulum()
    shared_data = unsafe_load(ptr)
    unsafe_store!(Ptr{UInt8}(pointer(arr)), UInt8(new_state))
end

function check_gui_state()
    """Check if GUI sent stop/pause signal"""
    arr, ptr = open_shared_pendulum()
    state_byte = unsafe_load(Ptr{UInt8}(pointer(arr)))
    return Char(state_byte)
end


function solve_ode()
    # Read parameters from shared memory
    params = read_shared_params()
    
    function ode!(du, u, p, t)

        theta = u[1]

        omega = u[2]


        # Extract parameters from shared memory struct

        mass = params.mass

        length = params.length

        damping = params.damping

        g = params.g



        du[1] = omega

        du[2] = -damping * omega - (g / length) * sin(theta)

    end

    u0 = [

        0.785398,

        0.0

    ]

    tspan = (params.t0, params.t1)
    dt = 0.01
    prob = ODEProblem(ode!, u0, tspan)

    outfile = open("models/pendulum.csv", "w")
    write(outfile, "t,theta,omega\n")

    step_callback = function (integrator)
        # Check for GUI state changes
        state = check_gui_state()
        
        if state == 'q'  # Quit signal
            close(outfile)
            terminate!(integrator)
            return true
        elseif state == 'p'  # Pause signal
            # For now, just continue (could implement pause logic later)
            return false
        end
        
        # Write data to file
        t = integrator.t
        y = integrator.u
        write(outfile, string(t))

        write(outfile, "," * string(y[1]))

        write(outfile, "," * string(y[2]))

        write(outfile, "\n")
        flush(outfile)
        return false
    end

    # DON'T set state to 'r' here - let GUI control it
    
    cb = DiscreteCallback((u,t,integrator)->true, step_callback)
    
    try
        sol = solve(prob, Tsit5(), dt=dt, adaptive=false, callback=cb)
        println("Simulation completed successfully")
    catch e
        println("Solver error: ", e)
        write_shared_state('e')  # Error state
    finally
        close(outfile)
    end
end

# Main execution loop
function main()
    println("Julia solver started for pendulum")
    
    # Wait briefly for initial parameters
    sleep(0.5)
    write_shared_state('i')  # Confirm ready
    
    # Check if shared memory file exists
    if !isfile("/dev/shm/pukaha_shared")
        error("Shared memory file not found - is the GUI controller running?")
    end
    
    try
        # Continuous loop - don't exit after one simulation
        while true
            state = check_gui_state()
            
            if state == 'r'
                println("Starting simulation...")
                solve_ode()
                # Don't break here! Continue looping to allow restarts
                write_shared_state('i')  # Set back to idle after completion
            elseif state == 'q'
                println("Received quit signal, exiting")
                break
            end
            
            sleep(0.1)  # Small delay to avoid busy waiting
        end
    catch e
        println("Julia solver error: ", e)
        write_shared_state('e')
    finally
        println("Julia solver stopped")
    end
end

# Run main function
main()

#!/usr/bin/env python3
'''
model_plots.py
==============
This script generates an interactive plot of a model's simulation results
using Plotly. It reads a CSV file generated by the ODE solver, creates a
Plotly figure, and serves it via a simple HTTP server. The plot is opened
in the default web browser.

Example:
```bash
./model_plots.py pendulum
```
Copyright: (c) 2025 Bijou M. Smith
License: GNU General Public License v3.0 <https://www.gnu.org/licenses/gpl-
'''


import os
import sys
import toml
import pandas as pd
import plotly.graph_objects as go
import plotly.io as pio
from plotly.subplots import make_subplots


def load_config(model_name):
    config_path = os.path.join("models", f"{model_name}.toml")
    if not os.path.exists(config_path):
        return {}
    return toml.load(config_path)



def plot_phase_2d(df, xvar, yvar, aspect=(1.0, 1.0)):
    x = df[xvar]
    y = df[yvar]

    fig = go.Figure()
    fig.add_trace(go.Scatter(x=x, y=y, mode='lines', name=f"{yvar} vs {xvar}"))

    x_min, x_max = x.min(), x.max()
    y_min, y_max = y.min(), y.max()

    fig.update_layout(
        title=f"Phase Plot: {yvar} vs {xvar}",
        xaxis=dict(title=xvar,
            range=[x_min, x_max], 
            showgrid=True,
            gridcolor='rgba(100, 100, 100, 0.3)',  
            zeroline=True,
            zerolinecolor='rgba(100, 100, 100, 0.5)',
            zerolinewidth=1
            ),
        yaxis=dict(title=yvar,
            range=[y_min, y_max],
            showgrid=True,
            gridcolor='rgba(100, 100, 100, 0.3)',
            zeroline=True,
            zerolinecolor='rgba(100, 100, 100, 0.5)',
            zerolinewidth=1,
            ),
        width=int(400 * aspect[0]),
        height=int(400 * aspect[1]),
        paper_bgcolor="black",
        plot_bgcolor="black",
        font=dict(color="white"),
    )
    return fig


def plot_phase_3d(df, xvar, yvar, zvar, aspect=(1.0, 1.0, 1.0)):
    x = df[xvar]
    y = df[yvar]
    z = df[zvar]

    fig = go.Figure()
    fig.add_trace(go.Scatter3d(
        x=x, y=y, z=z,
        mode='lines',
        line=dict(width=2),
        name=f"{zvar} vs {xvar},{yvar}"
    ))

    transparent = 'rgba(0,0,0,0)'

    fig.update_layout(
        title=f"3D Phase Plot: {zvar} vs {xvar},{yvar}",
        scene=dict(
            xaxis_title=xvar,
            yaxis_title=yvar,
            zaxis_title=zvar,
            xaxis=dict(
                showgrid=True,
                gridcolor='rgba(100, 100, 100, 0.3)',
                range=[x.min(), x.max()],
                zeroline=True,
                zerolinecolor='rgba(100, 100, 100, 0.5)',
                zerolinewidth=1,
                backgroundcolor=transparent
            ),
            yaxis=dict(
                range=[y.min(), y.max()],
                showgrid=True,
                gridcolor='rgba(100, 100, 100, 0.3)',
                zeroline=True,
                zerolinecolor='rgba(100, 100, 100, 0.5)',
                zerolinewidth=1,
                backgroundcolor=transparent
            ),
            zaxis=dict(
                range=[z.min(), z.max()],
                showgrid=True,
                gridcolor='rgba(100, 100, 100, 0.3)',
                zeroline=True,
                zerolinecolor='rgba(100, 100, 100, 0.5)',
                zerolinewidth=1,
                backgroundcolor=transparent
            ),
            aspectmode="manual",
            aspectratio=dict(
                x=aspect[0],
                y=aspect[1],
                z=aspect[2]
            ),
            bgcolor="black"
        ),
        paper_bgcolor="black",
        plot_bgcolor="black",
        font=dict(color="white"),
        width=500,
        height=500,
    )
    return fig

def plot_time_series(df, time_var, value_vars):
    if len(value_vars) == 1:
        return plot_single_time_series(df, time_var, value_vars[0])
    elif len(value_vars) == 2:
        return plot_dual_axis_time_series(df, time_var, value_vars)
    else:
        figs = []
        for var in value_vars:
            figs.append(plot_single_time_series(df, time_var, var))
        return figs


def plot_single_time_series(df, time_var, value_var):
   fig = go.Figure()
   fig.add_trace(go.Scatter(x=df[time_var], y=df[value_var],
                            mode='lines', name=value_var))
   fig.update_layout(
      title=f"Time Series: {value_var}",
        xaxis=dict( title=time_var,
        showgrid=True,
        gridcolor='rgba(100, 100, 100, 0.3)',
        zeroline=True,
        zerolinecolor='rgba(100, 100, 100, 0.5)',
        zerolinewidth=1
        ),
      yaxis=dict( title=value_var,  
        showgrid=True,
        gridcolor='rgba(100, 100, 100, 0.3)',
        zeroline=True,
        zerolinecolor='rgba(100, 100, 100, 0.5)',
        zerolinewidth=1
        ),
      paper_bgcolor="black",
      plot_bgcolor="black",
      font=dict(color="white"),
      height=400,
   )
   return fig


def plot_dual_axis_time_series(df, time_var, value_vars):
    var1, var2 = value_vars

    # Define line colors (you can change or parameterize these if needed)
    color1 = 'rgb(31, 119, 180)'  # blue
    color2 = 'rgb(255, 127, 14)'  # orange

    # Faint versions for grid/zero lines
    faint1 = 'rgba(31, 119, 180, 0.4)'
    faint2 = 'rgba(255, 127, 14, 0.4)'

    fig = go.Figure()
    fig.add_trace(go.Scatter(x=df[time_var], y=df[var1],
                                mode='lines', name=var1, yaxis='y1',
                                line=dict(color=color1)))
    fig.add_trace(go.Scatter(x=df[time_var], y=df[var2],
                                mode='lines', name=var2, yaxis='y2',
                                line=dict(color=color2)))

    fig.update_layout(
        title=f"Time Series: {var1} & {var2}",
        paper_bgcolor="black",
        plot_bgcolor="black",
        font=dict(color="white"),
        height=400,
        xaxis=dict(
            title=time_var,
            gridcolor='rgba(100,100,100,0.3)',
            # zeroline=True,
            # zerolinecolor='rgba(150, 150, 150, 0.4)',
            # zerolinewidth=1
        ),
        yaxis=dict(
            title=var1,
            color=color1,
            gridcolor='rgba(100,100,100,0.3)',
            zeroline=True,
            zerolinecolor=faint1,
            zerolinewidth=1,
            titlefont=dict(color=color1),
            tickfont=dict(color=color1)
        ),
        yaxis2=dict(
            title=var2,
            color=color2,
            overlaying='y',
            side='right',
            gridcolor='rgba(100,100,100,0.3)',
            zeroline=True,
            zerolinecolor=faint2,
            zerolinewidth=1,
            titlefont=dict(color=color2),
            tickfont=dict(color=color2)
        )
    )

    return fig


def main(model_name):
    csv_path = os.path.join("models", f"{model_name}.csv")
    df = pd.read_csv(csv_path)

    # Load the toml config for this model
    config = load_config(model_name)
    time_var = "t"
    value_vars = [col for col in df.columns if col != time_var]

    # Time series plots
    time_series_vars = config.get("time_series", value_vars)
    max_vars_per_plot = config.get("max_vars_per_plot", 2)

    figs = []

    # --- Handle time series plots (always return a list of figs) ---
    if len(time_series_vars) > max_vars_per_plot:
        for i in range(0, len(time_series_vars), max_vars_per_plot):
            subset = time_series_vars[i:i + max_vars_per_plot]
            fig_list = plot_time_series(df, time_var, subset)
            if isinstance(fig_list, list):
                figs.extend(fig_list)
            else:
                figs.append(fig_list)
    else:
        fig_list = plot_time_series(df, time_var, time_series_vars)
        if isinstance(fig_list, list):
            figs.extend(fig_list)
        else:
            figs.append(fig_list)

    # --- Phase plots from toml ---
    phase_cfgs = config.get("plots", {}).get("phase", [])
    if not phase_cfgs:
        if len(value_vars) in (2, 3):
            phase_cfgs = [{"vars": value_vars}]

    for cfg in phase_cfgs:
        vars_ = cfg["vars"]
        aspect = cfg.get("aspect", [1.0] * len(vars_))

        if len(vars_) == 2:
            fig = plot_phase_2d(df, vars_[0], vars_[1], aspect)
        elif len(vars_) == 3:
            fig = plot_phase_3d(df, vars_[0], vars_[1], vars_[2], aspect)
        else:
            print(f"Invalid phase plot config: {vars_}")
            continue

        figs.append(fig)

    # --- Export each fig to HTML with black background patch ---
    html_path = os.path.join("models", f"{model_name}.html")
    html_str = ""
    plot_count = 0
    with open(html_path, "w") as f:
        for fig in figs:
            html_str = html_str + pio.to_html(fig, full_html=True, include_plotlyjs="cdn")
            #html_str = pio.to_html(fig, full_html=False, include_plotlyjs="cdn")
            plot_count += 1
            if plot_count ==1 :
                html_str = html_str.replace("<head>",
                                            f"<head><title>Model: {model_name}</title><style>body{{background-color:black;}}</style>"
                                            )
                html_str = html_str.replace("<body>",
                                            f'<body>\n<h2 style="color:lightblue;">Model: {model_name}</h2>'
                                            )
        f.write(html_str)

    print(f"HTML plot written to {html_path}")


if __name__ == "__main__":
    import argparse
    parser = argparse.ArgumentParser(description="Generate interactive Plotly plots for a given model's simulation results.")
    parser.add_argument("model_name", help="The name of the model (e.g., 'pendulum').")
    args = parser.parse_args()
    sys.argv = [sys.argv[0], args.model_name]
    main(args.model_name)


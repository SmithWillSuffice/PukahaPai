#!/usr/bin/env python3
'''
model_plots.py
==============
This script generates an interactive plot of a model's simulation results
using Plotly. It reads a CSV file generated by the ODE solver, creates a
Plotly figure, and serves it via a simple HTTP server. The plot is opened
in the default web browser.

Example:
```bash
./model_plots.py pendulum
```
Copyright: (c) 2025 Bijou M. Smith
License: GNU General Public License v3.0 <https://www.gnu.org/licenses/gpl-
'''

## Server HTML --- allowed for PORT so browser dark mode could be disabled

# import sys
# import pandas as pd
# import plotly.graph_objects as go
# from plotly.subplots import make_subplots
# import plotly.io as pio
# from pathlib import Path
# from http.server import HTTPServer, SimpleHTTPRequestHandler
# import threading
# import webbrowser
# import os

# # ---- Config ----
# MODELS_DIR = Path("models")
# PORT = 55599
# BACKGROUND_COLOR = "black"

# # ---- Argument ----
# if len(sys.argv) != 2:
#     print("Usage: ./plot_model.py <model_name>")
#     sys.exit(1)

# model_name = sys.argv[1]
# csv_path = MODELS_DIR / f"{model_name}.csv"
# html_path = MODELS_DIR / f"{model_name}.html"

# # ---- Load CSV ----
# try:
#     df = pd.read_csv(csv_path)
# except FileNotFoundError:
#     print(f"Error: CSV not found: {csv_path}")
#     sys.exit(1)

# if "t" not in df.columns:
#     print("Error: CSV must contain a 't' column.")
#     sys.exit(1)

# # ---- Prepare Plot ----
# variables = [col for col in df.columns if col != "t"]
# n_vars = len(variables)

# fig = make_subplots(
#     rows=n_vars,
#     cols=1,
#     shared_xaxes=True,
#     subplot_titles=variables,
#     vertical_spacing=0.03
# )

# for i, var in enumerate(variables, start=1):
#     fig.add_trace(
#         go.Scatter(x=df["t"], y=df[var], mode="lines", name=var),
#         row=i,
#         col=1
#     )

# fig.update_layout(
#    height=300 * n_vars,
#    template="plotly_dark",
#    paper_bgcolor=BACKGROUND_COLOR,
#    plot_bgcolor=BACKGROUND_COLOR,
#    font=dict(color="white"),
#    showlegend=False,
#    title_text=f"Model: {model_name}"
# )

# # ---- Patch HTML Background ----
# html_str = pio.to_html(fig, full_html=True, include_plotlyjs="cdn")
# html_str = html_str.replace(
#    "<head>",
#    "<head><style>body{background-color:black;}</style>"
# )

# # ---- Save HTML ----
# with open(html_path, "w") as f:
#     f.write(html_str)

# print(f"HTML plot saved to: {html_path}")

# # ---- Serve & Open ----
# def serve_and_open():
#     os.chdir(MODELS_DIR)
#     server_address = ("", PORT)
#     httpd = HTTPServer(server_address, SimpleHTTPRequestHandler)
#     url = f"http://localhost:{PORT}/{model_name}.html"
#     print(f"Serving at {url}")
#     webbrowser.open(url)
#     httpd.serve_forever()

# thread = threading.Thread(target=serve_and_open, daemon=True)
# thread.start()
# thread.join()




## Standalone HTML --- old version

# import sys
# import os
# import pandas as pd
# import plotly.graph_objects as go
# from plotly.offline import plot as plotly_plot
# import toml


# def load_config(model_name):
#     config_path = os.path.join("models", f"{model_name}.toml")
#     if os.path.exists(config_path):
#         return toml.load(config_path)
#     return {}


# def compute_aspect_ratio(df, vars_):
#     """Return aspect ratio tuple from data ranges."""
#     ranges = [df[v].max() - df[v].min() for v in vars_]
#     # Normalize so smallest range is 1.0
#     min_range = min(ranges) if min(ranges) > 0 else 1.0
#     return tuple(round(r / min_range, 4) for r in ranges)


# def plot_time_series(df, time_var, value_vars):
#     fig = go.Figure()
#     for var in value_vars:
#         fig.add_trace(go.Scatter(x=df[time_var], y=df[var], mode='lines', name=var))
#     fig.update_layout(
#         title="Time Series",
#         xaxis_title=time_var,
#         yaxis_title="Values",
#         paper_bgcolor="black",
#         plot_bgcolor="black",
#         font=dict(color='white'),
#         autosize=True,
#         width=None,
#         height=400,
#     )
#     return fig


# def plot_phase_2d(df, xvar, yvar, ratio=None):
#     fig = go.Figure()
#     fig.add_trace(go.Scatter(x=df[xvar], y=df[yvar], mode='lines', name=f"{yvar} vs {xvar}"))

#     if ratio is None:
#         xscale, yscale = compute_aspect_ratio(df, [xvar, yvar])
#     else:
#         xscale, yscale = ratio

#     fig.update_layout(
#         title=f"Phase Plot: {yvar} vs {xvar}",
#         xaxis_title=xvar,
#         yaxis_title=yvar,
#         paper_bgcolor="black",
#         plot_bgcolor="black",
#         font=dict(color='white'),
#         width=500,
#         height=500,
#     )
#     fig.update_yaxes(scaleanchor="x", scaleratio=yscale / xscale)
#     return fig


# def plot_phase_3d(df, xvar, yvar, zvar, ratio=None):
#     if ratio is None:
#         xscale, yscale, zscale = compute_aspect_ratio(df, [xvar, yvar, zvar])
#     else:
#         xscale, yscale, zscale = ratio

#     fig = go.Figure()
#     fig.add_trace(go.Scatter3d(
#         x=df[xvar], y=df[yvar], z=df[zvar],
#         mode='lines',
#         line=dict(width=2),
#         name=f"{zvar} vs {xvar}, {yvar}"
#     ))

#     fig.update_layout(
#         title=f"3D Phase Plot: {zvar} vs {xvar}, {yvar}",
#         scene=dict(
#             xaxis_title=xvar,
#             yaxis_title=yvar,
#             zaxis_title=zvar,
#             xaxis=dict(backgroundcolor="black", gridcolor="gray"),
#             yaxis=dict(backgroundcolor="black", gridcolor="gray"),
#             zaxis=dict(backgroundcolor="black", gridcolor="gray"),
#             aspectmode="manual",
#             aspectratio=dict(x=xscale, y=yscale, z=zscale)
#         ),
#         paper_bgcolor="black",
#         font=dict(color='white'),
#         width=600,
#         height=600,
#     )
#     return fig


# def main():
#     if len(sys.argv) != 2:
#         print("Usage: python plot_model.py <model_name>")
#         sys.exit(1)

#     model_name = sys.argv[1]
#     csv_path = os.path.join("models", f"{model_name}.csv")
#     df = pd.read_csv(csv_path)

#     config = load_config(model_name)
#     time_var = "t"
#     value_vars = [col for col in df.columns if col != time_var]

#     # Time series
#     time_series_vars = config.get("time_series", value_vars)
#     fig_ts = plot_time_series(df, time_var, time_series_vars)

#     # Phase plots
#     phase_plots = config.get("phase_plots")
#     if not phase_plots:
#         if len(value_vars) in [2, 3]:
#             phase_plots = [value_vars]

#     figs = [fig_ts]

#     if phase_plots:
#         ratio_config = config.get("aspect_ratios", {})
#         for vars_ in phase_plots:
#             ratio = tuple(ratio_config.get(":".join(vars_), [])) or None
#             if len(vars_) == 2:
#                 figs.append(plot_phase_2d(df, *vars_, ratio=ratio))
#             elif len(vars_) == 3:
#                 figs.append(plot_phase_3d(df, *vars_, ratio=ratio))
#             else:
#                 print(f"Invalid phase plot config: {vars_}")



#     # Export to single HTML
#     html_path = os.path.join("models", f"{model_name}.html")
#     with open(html_path, "w") as f:
#         for fig in figs:
#             f.write(plotly_plot(fig, include_plotlyjs='cdn', output_type='div'))

#     print(f"HTML plot written to {html_path}")


# if __name__ == "__main__":
#     main()

import os
import sys
import toml
import pandas as pd
import plotly.graph_objects as go
import plotly.io as pio
from plotly.subplots import make_subplots


def load_config(model_name):
    config_path = os.path.join("models", f"{model_name}.toml")
    if not os.path.exists(config_path):
        return {}
    return toml.load(config_path)



def plot_phase_2d(df, xvar, yvar, aspect=(1.0, 1.0)):
    x = df[xvar]
    y = df[yvar]

    fig = go.Figure()
    fig.add_trace(go.Scatter(x=x, y=y, mode='lines', name=f"{yvar} vs {xvar}"))

    x_min, x_max = x.min(), x.max()
    y_min, y_max = y.min(), y.max()

    fig.update_layout(
        title=f"Phase Plot: {yvar} vs {xvar}",
        xaxis=dict(title=xvar,
            range=[x_min, x_max], 
            showgrid=True,
            gridcolor='rgba(100, 100, 100, 0.3)',  
            zeroline=True,
            zerolinecolor='rgba(100, 100, 100, 0.5)',
            zerolinewidth=1
            ),
        yaxis=dict(title=yvar,
            range=[y_min, y_max],
            showgrid=True,
            gridcolor='rgba(100, 100, 100, 0.3)',
            zeroline=True,
            zerolinecolor='rgba(100, 100, 100, 0.5)',
            zerolinewidth=1,
            ),
        width=int(400 * aspect[0]),
        height=int(400 * aspect[1]),
        paper_bgcolor="black",
        plot_bgcolor="black",
        font=dict(color="white"),
    )
    return fig


# def plot_phase_3d(df, xvar, yvar, zvar, aspect=(1.0, 1.0, 1.0)):
#     x = df[xvar]
#     y = df[yvar]
#     z = df[zvar]

#     fig = go.Figure()
#     fig.add_trace(go.Scatter3d(
#         x=x, y=y, z=z,
#         mode='lines',
#         line=dict(width=2),
#         name=f"{zvar} vs {xvar},{yvar}"
#     ))

#     fig.update_layout(
#         title=f"3D Phase Plot: {zvar} vs {xvar},{yvar}",
#         scene=dict(
#             xaxis_title=xvar,
#             yaxis_title=yvar,
#             zaxis_title=zvar,
#             xaxis=dict(
#                 showgrid=True,
#                 gridcolor='rgba(100, 100, 100, 0.3)',
#                 range=[x.min(), x.max()],
#                 zeroline=True,
#                 zerolinecolor='rgba(100, 100, 100, 0.5)',
#                 zerolinewidth=1
#                 ),
#             yaxis=dict(
#                 range=[y.min(), y.max()],
#                 showgrid=True,
#                 gridcolor='rgba(100, 100, 100, 0.3)',
#                 zeroline=True,
#                 zerolinecolor='rgba(100, 100, 100, 0.5)',
#                 zerolinewidth=1
#                 ),
#             zaxis=dict(
#                 range=[z.min(), z.max()], 
#                 showgrid=True,
#                 gridcolor='rgba(100, 100, 100, 0.3)',
#                 zeroline=True,
#                 zerolinecolor='rgba(100, 100, 100, 0.5)',
#                 zerolinewidth=1
#                 ),
#             aspectmode="manual",
#             aspectratio=dict(
#                 x=aspect[0],
#                 y=aspect[1],
#                 z=aspect[2]
#             ),
#             bgcolor="black"
#         ),
#         paper_bgcolor="black",
#         plot_bgcolor="black",
#         font=dict(color="white"),
#         width=500,
#         height=500,
#     )
#     return fig
def plot_phase_3d(df, xvar, yvar, zvar, aspect=(1.0, 1.0, 1.0)):
    x = df[xvar]
    y = df[yvar]
    z = df[zvar]

    fig = go.Figure()
    fig.add_trace(go.Scatter3d(
        x=x, y=y, z=z,
        mode='lines',
        line=dict(width=2),
        name=f"{zvar} vs {xvar},{yvar}"
    ))

    transparent = 'rgba(0,0,0,0)'

    fig.update_layout(
        title=f"3D Phase Plot: {zvar} vs {xvar},{yvar}",
        scene=dict(
            xaxis_title=xvar,
            yaxis_title=yvar,
            zaxis_title=zvar,
            xaxis=dict(
                showgrid=True,
                gridcolor='rgba(100, 100, 100, 0.3)',
                range=[x.min(), x.max()],
                zeroline=True,
                zerolinecolor='rgba(100, 100, 100, 0.5)',
                zerolinewidth=1,
                backgroundcolor=transparent
            ),
            yaxis=dict(
                range=[y.min(), y.max()],
                showgrid=True,
                gridcolor='rgba(100, 100, 100, 0.3)',
                zeroline=True,
                zerolinecolor='rgba(100, 100, 100, 0.5)',
                zerolinewidth=1,
                backgroundcolor=transparent
            ),
            zaxis=dict(
                range=[z.min(), z.max()],
                showgrid=True,
                gridcolor='rgba(100, 100, 100, 0.3)',
                zeroline=True,
                zerolinecolor='rgba(100, 100, 100, 0.5)',
                zerolinewidth=1,
                backgroundcolor=transparent
            ),
            aspectmode="manual",
            aspectratio=dict(
                x=aspect[0],
                y=aspect[1],
                z=aspect[2]
            ),
            bgcolor="black"
        ),
        paper_bgcolor="black",
        plot_bgcolor="black",
        font=dict(color="white"),
        width=500,
        height=500,
    )
    return fig

def plot_time_series(df, time_var, value_vars):
    if len(value_vars) == 1:
        return plot_single_time_series(df, time_var, value_vars[0])
    elif len(value_vars) == 2:
        return plot_dual_axis_time_series(df, time_var, value_vars)
    else:
        figs = []
        for var in value_vars:
            figs.append(plot_single_time_series(df, time_var, var))
        return figs


def plot_single_time_series(df, time_var, value_var):
   fig = go.Figure()
   fig.add_trace(go.Scatter(x=df[time_var], y=df[value_var],
                            mode='lines', name=value_var))
   fig.update_layout(
      title=f"Time Series: {value_var}",
        xaxis=dict( title=time_var,
        showgrid=True,
        gridcolor='rgba(100, 100, 100, 0.3)',
        zeroline=True,
        zerolinecolor='rgba(100, 100, 100, 0.5)',
        zerolinewidth=1
        ),
      yaxis=dict( title=value_var,  
        showgrid=True,
        gridcolor='rgba(100, 100, 100, 0.3)',
        zeroline=True,
        zerolinecolor='rgba(100, 100, 100, 0.5)',
        zerolinewidth=1
        ),
      paper_bgcolor="black",
      plot_bgcolor="black",
      font=dict(color="white"),
      width=1200,
      height=400,
   )
   return fig


def plot_dual_axis_time_series(df, time_var, value_vars):
    var1, var2 = value_vars

    # Define line colors (you can change or parameterize these if needed)
    color1 = 'rgb(31, 119, 180)'  # blue
    color2 = 'rgb(255, 127, 14)'  # orange

    # Faint versions for grid/zero lines
    faint1 = 'rgba(31, 119, 180, 0.4)'
    faint2 = 'rgba(255, 127, 14, 0.4)'

    fig = go.Figure()
    fig.add_trace(go.Scatter(x=df[time_var], y=df[var1],
                                mode='lines', name=var1, yaxis='y1',
                                line=dict(color=color1)))
    fig.add_trace(go.Scatter(x=df[time_var], y=df[var2],
                                mode='lines', name=var2, yaxis='y2',
                                line=dict(color=color2)))

    fig.update_layout(
        title=f"Time Series: {var1} & {var2}",
        paper_bgcolor="black",
        plot_bgcolor="black",
        font=dict(color="white"),
        width=1200,
        height=400,
        xaxis=dict(
            title=time_var,
            gridcolor='rgba(100,100,100,0.3)',
            # zeroline=True,
            # zerolinecolor='rgba(150, 150, 150, 0.4)',
            # zerolinewidth=1
        ),
        yaxis=dict(
            title=var1,
            color=color1,
            gridcolor='rgba(100,100,100,0.3)',
            zeroline=True,
            zerolinecolor=faint1,
            zerolinewidth=1,
            titlefont=dict(color=color1),
            tickfont=dict(color=color1)
        ),
        yaxis2=dict(
            title=var2,
            color=color2,
            overlaying='y',
            side='right',
            gridcolor='rgba(100,100,100,0.3)',
            zeroline=True,
            zerolinecolor=faint2,
            zerolinewidth=1,
            titlefont=dict(color=color2),
            tickfont=dict(color=color2)
        )
    )

    return fig


def main():
    if len(sys.argv) != 2:
        print("Usage: python plot_model.py <model_name>")
        sys.exit(1)

    model_name = sys.argv[1]
    csv_path = os.path.join("models", f"{model_name}.csv")
    df = pd.read_csv(csv_path)

    # Load the toml config for this model
    config = load_config(model_name)
    time_var = "t"
    value_vars = [col for col in df.columns if col != time_var]

    # Time series plots
    time_series_vars = config.get("time_series", value_vars)
    max_vars_per_plot = config.get("max_vars_per_plot", 2)

    figs = []

    # --- Handle time series plots (always return a list of figs) ---
    if len(time_series_vars) > max_vars_per_plot:
        for i in range(0, len(time_series_vars), max_vars_per_plot):
            subset = time_series_vars[i:i + max_vars_per_plot]
            fig_list = plot_time_series(df, time_var, subset)
            if isinstance(fig_list, list):
                figs.extend(fig_list)
            else:
                figs.append(fig_list)
    else:
        fig_list = plot_time_series(df, time_var, time_series_vars)
        if isinstance(fig_list, list):
            figs.extend(fig_list)
        else:
            figs.append(fig_list)

    # --- Phase plots from toml ---
    phase_cfgs = config.get("plots", {}).get("phase", [])
    if not phase_cfgs:
        if len(value_vars) in (2, 3):
            phase_cfgs = [{"vars": value_vars}]

    for cfg in phase_cfgs:
        vars_ = cfg["vars"]
        aspect = cfg.get("aspect", [1.0] * len(vars_))

        if len(vars_) == 2:
            fig = plot_phase_2d(df, vars_[0], vars_[1], aspect)
        elif len(vars_) == 3:
            fig = plot_phase_3d(df, vars_[0], vars_[1], vars_[2], aspect)
        else:
            print(f"Invalid phase plot config: {vars_}")
            continue

        figs.append(fig)

    # --- Export each fig to HTML with black background patch ---
    html_path = os.path.join("models", f"{model_name}.html")
    with open(html_path, "w") as f:
        for fig in figs:
            html_str = pio.to_html(fig, full_html=True, include_plotlyjs="cdn")
            html_str = html_str.replace(
                "<head>",
                "<head><style>body{background-color:black;}</style>"
            )
            f.write(html_str)

    print(f"HTML plot written to {html_path}")


if __name__ == "__main__":
    main()

